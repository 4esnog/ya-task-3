#Задание

Склонируйте код из репозитория: `git clone https://github.com/shri-msk-2016/task3.git`

Выполните `npm install`, а затем `npm start` и откройте приложение в браузере (<http://localhost:3000>).

Приложение позволяет добавлять и редактировать данные студентов ШРИ (ФИО, ссылку на фотографию и краткую информацию). Для работы в офлайне оно использует ServiceWorker, позволяя при этом, как минимум, просматривать данные студентов.

Однако при реализации были допущены несколько ошибок:

* Без подключения к серверу приложение не работает.
* Не всегда обновляется список студентов после добавления нового.

Найдите и исправьте ошибки. В качестве дополнительного задания вы можете реализовать добавление студентов в офлайне с последующей синхронизацией. При выполнении обратите внимание на способы определения режима «онлайн/офлайн».

Результат пришлите в виде ссылки на https://github.com

##Что мы проверяем этим заданием?

Мы хотим проверить вашу способность разобраться в незнакомом коде и/или API. Также с помощью этого задания мы оценим ваш навык отладки. Поэтому прокомментируйте, пожалуйста, в коде или текстовом файле README ход ваших мыслей — какие ошибки и как вы нашли, почему они возникли и какие способы исправления существуют. Мы не ограничиваем вас в использовании сторонних инструментов и библиотек, однако при их использовании также ожидаем комментариев, в которых вы расскажете, зачем и почему было использовано то или иное средство.

#Решение

Для начала с помошью инструментов отладки Service Workers (СВ) в Google Chrome посмотрим, регистрируется ли воркер. Не регистрируется. В отладчике видна ошибка `Uncaught SyntaxError: missing ) after argument list` в 36 строке `worker.js`:
```
return event.respondWith(
  getFromCache(event.request).catch(fetchAndPutToCache);
);
```

Уберём `;`, перезагружаем страницу сприложением.
Воркер зарегистрирован и активирован. Отключаемся от сети, перезагружаем.

Из кэша ничего не грузится. Возвращаемся к инструментам Chrome и видим, что `Scope` для нашего СВ равен `localhost:8080/js/`. Это значит, что СВ контролирует только все те ресурсы, которые находятся в `js/`, упуская при этом всё остальное.

Переместим `worker.js` на один уровень выше (рядом с `index.html`), исправим пути в коде регистрации воркера и коде самого воркера.

Было:
```javascript
// index.html
navigator.serviceWorker.register('/js/worker.js');

// worker.js
var urlsToCache = [
  '/',
  '/index.css',
  '/index.js'
];
```

Стало:
```javascript
// index.html
navigator.serviceWorker.register('/worker.js');

// worker.js
var urlsToCache = [
  '/',
  '/css/index.css',
  '/js/index.js'
];
```

Возвращаем соединение, перезагружаем страницу (пока всё хорошо), отключаем соединение, снова перезагружаем страницу. И тут видим массу ошибок. Заглянув в лог нашего СВ, обнаруживаем, что при обработке запросов воркер теряет адреса запрошенных ресурсов: `"sourceURL": ""`.

Вернёмся к `worker.js`. Анализируем, как воркер обрабатывает запросы, и замечаем, что функция `fetchAndPutToCache` должна принимать объект запроса. Но в 36 строке (той самой, где была допущена синтаксическая ошибка), где эта самая функция может быть вызвана при отсутствии запрашиваемых ресурсов в кэше (очевидно, этот вызов обязательно произойдёт), никакие аргументы ей не передаются.

Решаем эту проблему каррингом:

Было:
```javascript
getFromCache(event.request).catch(fetchAndPutToCache)
```

Стало:
```javascript
getFromCache(event.request).catch(fetchAndPutToCache.bind(this, event.request))
```

Попутно замечаем интересную конструкцию `Promise.race([...])`. Очевидно, что использовать её в данном случае нельзя, так как она одновременно и запрашивает данные с сервера, и кладёт их в кэш, попутно возвращая, и отдаёт данные из кэша, которые либо только что были туда записаны, либо через мгновение будут перезаписаны. В общем, так не пойдёт.

Меняем данную конструкцию:

```javascript
fetchAndPutToCache(event.request)getFromCache(event.request).catch(fetchAndPutToCache.bind(this, event.request))
```